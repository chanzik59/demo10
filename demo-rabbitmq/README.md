# rabbitMq笔记
### 交换机类型
#### 1 直接交换机  需要和队列进行路由键绑定，在发送消息的时候需要带上路由键，不支持模糊匹配
#### 2 扇出交换机  不需要和队列进行路由键绑定，发送消息的时候路由键无论有没有上送，都会发送到跟交换机相绑定的所有队列
#### 3 主题交换机  需要和队列进行绑定，发送消息需要携带上路由键，可以模糊匹配，#匹配单个，*匹配任意

### TTL
#### 1 队列ttl设置了队列的ttl，队列中的消息按照队列ttl进行过期删除
#### 2 消息ttl在消息发送的时候携带ttl信息，只有在队列头部的消息才会判断ttl是否过期

### 消息确认机制
#### 1 ack 可以开启手动ack或者自动ack
#### 2 没有被ack的消息成为unack状态，下次重启应用的时候会入队重新消费
#### 3 ack可以分为三种 ack  nack  reject
ack 表示消息被正确处理，nack  可以批量处理，可以重新入队，如果没有重新入队的话会丢弃，或者进入死信  reject 通nack 只能处理单条信息


### 发布者确认
1. 发布者确认在，rabbiTemplate 中需要配置开启
2. 发布者确认能够，确保消息是否到达交换机
3. 触发条件 1 找不到交换机为 ack为false 2 发送交换机，但是路由队列失败 ack 为true 3 找不到交换机和路由队列 ack为false  4 成功发送到队列 ack为true

### 消费者确认
1. 消费者确认在rabbitTemplate中需要配置开启
2. 消费者确认，只要在消息发送到交换机但是无法路由到队列触发

### 死信息队列
#### 配置 需要使用死信，需要给指定队列配置死信队列参数 以及死信路由键 一般使用直接类型交换机
#### 进入死信队列的情况
1. 达到ttl 无论是队列ttl还是消息ttl 消息过期会进入死信
2.  消息被nack 或者reject 并且没有重新入队
3.  达到队列最大长度，无法进入队列就会进入死信队列
4.  达到消息最大重试次数


### 消息重试
消息重试次数需要开启，可以设置重试次数，和间隔时间
1. 如果是自动ack则，达到最大重试次数则进入死信或者失败处理，
2. 如果是手动ack，则需要在消费端自行判断重试次数并且进行ack


### 备份交换机
#### 配置：备份交换机需要在交换机声明的时候指定备份交换机一般使用扇出类型
#### 使用：在主交换机，消息路由队列失败的时候，消息会转发备份交换机

### 延时队列
1. 使用死信队列+消息ttl  问题，时间会不准确，因为只有队列头部的消息才会判断ttl是否过去
2. 死信队列+队列ttl  延时时间准确，但是ttl时间太过固定，无法灵活设置
3. 使用延时插件，安装延时插件，设置delay时间实现延时发送

### 消费模式
1. 推模式，由队列发送到消费者，速度快，但是不可控，最常用的模式
2. 拉模式basicGet 实现，一次只能拉取一条消息，按照先进先出原则

### 持久化
1. 交换机持久化 ，在交换机声明的时候实现，没有持久化的交换机在重启之后会消失
2. 队列持久化，在队列声明的时候实现，没有持久化的队列在重启之后会消失
3. 消息持久化，在消息发送的时候携带持久化参数，消息的持久化依赖队列持久化，否则无效